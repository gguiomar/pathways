
from matplotlib import rc
import numpy as np
import matplotlib.pyplot as plt
from pylab import *
import matplotlib.gridspec as gridspec
import copy as copy
import scipy as sp
from scipy import ndimage
from scipy.optimize import curve_fit
import pandas as pd

class pathway_analysis_v6():

    """
    This class's main purpose is to generate useful visualiations of the data generated by the artificial agents.
    It takes as input a data structure called "sim_data", from which it should be able to get all necessary
    information.
    """

    def __init__(self, sim_data, param):
        self.sim_data = sim_data
        self.param = param

        self.sim_n = len(sim_data) # number of simulations in this data structure

        if self.sim_n > 1:
            self.multiple_sim_flag = 1
        else:
            self.multiple_sim_flag = 0

    """
    USEFUL FUNCTIONS
    These are basic functions used in calculating agent performance measures and other simple transformations
    on vectors that are recurrently used in the code.
    """
    
    def calc_perf(self, sd):
        """Calculates the performance of the agent on a single experiment."""
        choices = sd['choices']
        return sum(choices)/choices.shape[0]
    
    def normalise_vec(self, vec):
        """normalises a vector"""
        return (vec-min(vec))/(max(vec)-min(vec))

    def min_max_norm(self, vec):
        return (vec-np.min(vec))/(np.max(vec)-np.min(vec)+0.000001)

    def get_bulk_data(self):

        A = self.sim_data['A']
        last_stl = self.param['second_tone_list'][-1]
        env_size = int(self.param['n_states']*2)

        # change these indexes to be dependent on the parameters
        second_t = self.param['n_states'] + last_stl
        idx = np.concatenate([np.linspace(0, last_stl, last_stl).astype(int),
                              np.linspace(second_t, env_size, env_size-second_t).astype(int)], axis=0)

        t_axis_dl = np.linspace(0, 2.5, idx[0:last_stl].shape[0])
        t_axis_ch = np.linspace(2.6, 5, idx[last_stl-1:-1].shape[0])
        t_axis = np.concatenate((t_axis_dl, t_axis_ch), axis=0)

        return t_axis, A, idx

    def grid_plot_pathways_bulk(self, fig_size):
        """
        Plotting for a single simulation
        """

        t_axis, A, idx = self.get_bulk_data()

        # create the figure object
        columns = 1
        rows = 3
        fig = plt.figure(figsize=(fig_size[0], fig_size[1]))
        gs = gridspec.GridSpec(columns, rows)
        gs.update(hspace=0.5)

        ax = []
        for c in range(columns):
            ax.append([])
            for r in range(rows):
                ax[c].append(fig.add_subplot(gs[c, r]))

        ax[0][0].plot(t_axis, A[0, idx, 1], 'b', label='D1')
        ax[0][0].plot(t_axis, A[1, idx, 1], 'r', label='A2A')
        ax[0][0].legend()
        ax[0][0].set_xlabel('time relative to initiation (s)')
        ax[0][0].set_ylabel('$A(z_t,CL)$')
        ax[0][0].axvline(2.5, color='k', linewidth=0.3)
        ax[0][0].spines['right'].set_visible(False)
        ax[0][0].spines['top'].set_visible(False)
        ax[0][0].yaxis.set_ticks_position('left')
        ax[0][0].xaxis.set_ticks_position('bottom')

        ax[0][1].plot(t_axis, A[0, idx, 0], 'b', label='D1')
        ax[0][1].plot(t_axis, A[1, idx, 0], 'r', label='A2A')
        ax[0][1].legend()
        ax[0][1].set_xlabel('time relative to initiation (s)')
        ax[0][1].set_ylabel('$A(z_t,CS)$')
        ax[0][1].axvline(2.5, color='k', linewidth=0.3)
        ax[0][1].spines['right'].set_visible(False)
        ax[0][1].spines['top'].set_visible(False)
        ax[0][1].yaxis.set_ticks_position('left')
        ax[0][1].xaxis.set_ticks_position('bottom')

        ax[0][2].plot(t_axis, self.sim_data['Ac']
                    [idx, 0], 'g', label='CL Intention')
        ax[0][2].plot(t_axis, self.sim_data['Ac'][idx, 1],
                    'purple', label='CR Intention')
        ax[0][2].set(xlabel='time relative to initialization(s)',
                    ylabel='$A^C(z_t,a_t)$')
        ax[0][2].spines['right'].set_visible(False) 
        ax[0][2].spines['top'].set_visible(False)
        ax[0][2].yaxis.set_ticks_position('left')
        ax[0][2].xaxis.set_ticks_position('bottom')
        #ax2.title('History dependent observer')

        #fig.savefig(fig_path + 'bulk.png', bbox_inches='tight', dpi=400)

        return fig
    
    def get_movement_data(self):
        
        dp_len = self.param['n_states']
        total_len = dp_len*2

        dp_data2 = self.sim_data['behaviour_h2']
        bf_l2 = (dp_data2 == 0).astype(int)
        bf_r2 = (dp_data2 == 1).astype(int)
        sum_bf = np.sum(bf_l2, axis=0) + np.sum(bf_r2, axis=0)
        last_tone = self.param['second_tone_list'][-1]
        mov_long = self.min_max_norm(np.concatenate((sum_bf[0:last_tone], sum_bf[dp_len+last_tone:total_len])))

        idx = np.concatenate([np.linspace(0, last_tone, last_tone).astype(int), 
                            np.linspace(dp_len+last_tone-1, total_len, total_len-(dp_len+last_tone)).astype(int)], axis=0)
        t_axis = np.linspace(0, 5, idx.shape[0])
        
        return t_axis, mov_long

    def plot_movement_data(self, sim_data):

        t_axis, mov_long = self.get_movement_data()

        fig, ax = plt.subplots(figsize=(5, 5))
        ax.plot(t_axis, mov_long, 'k')
        ax.set(xlabel='time since initialization(s)',
            ylabel='total movement (normalised)')
        ax.spines['right'].set_visible(False)
        ax.spines['top'].set_visible(False)
        ax.yaxis.set_ticks_position('left')
        ax.xaxis.set_ticks_position('bottom')

        #fig.savefig(fig_path + 'movement.png', bbox_inches='tight', dpi=400)

        return fig

    def get_breaking_fixation_data(self, i_ep):

        """This function outputs the time in seconds when the agent broke fixation for either left or right actions"""

        # first we get the data and identify the breaking fixations
        # only grabs the choices up until the states of the
        # last second tone
        dp_data = self.sim_data['behaviour_h2'][i_ep:-1, 0:self.param['second_tone_list'][-1]]

        # these two vectors contain 1s where a left or right action was chosen during the delay period
        # zeros otherwise
        bf_l = (dp_data == 0).astype(int)
        bf_r = (dp_data == 1).astype(int)

        # these two vectors contain the state where the choice was made for either left or right
        state_ct_l = []
        state_ct_r = []
        for e, d in zip(bf_l, bf_r):
            if np.where(e == 1)[0].size != 0:
                state_ct_l.append(np.where(e == 1)[0])
            if np.where(d == 1)[0].size != 0:
                state_ct_r.append(np.where(d == 1)[0])
        state_ct_l = np.asarray(state_ct_l).flatten()
        state_ct_r = np.asarray(state_ct_r).flatten()

        # create a temporal axis that goes from 0 to 2.5s to mimic the real data
        time_coor = np.linspace(0, 2.5, len(np.unique(state_ct_l)))
        uniq_st = np.unique(state_ct_l)

        # match the temporal index to time in seconds
        time_match = []
        for e, d in zip(time_coor, uniq_st):
            time_match.append([d, e])
        time_match = np.asarray(time_match)

        # now change the state indexes to temporal indexes in the
        # two vectors
        state_ct_l2 = []
        state_ct_r2 = []
        for e, f in zip(state_ct_l, state_ct_r):
            for d in time_match:
                if e == d[0]:
                    state_ct_l2.append(d[1])
                if f == d[0]:
                    state_ct_r2.append(d[1])
        state_ct_l2 = np.asarray(state_ct_l2)
        state_ct_r2 = np.asarray(state_ct_r2)

        # final vector contaning the time of breaking fixation in seconds
        return state_ct_l2, state_ct_r2

    def plot_breaking_fixation_distributions(self, fig_size, i_ep, bin_size):

        state_ct_l2, state_ct_r2 = self.get_breaking_fixation_data(i_ep)
        #state_ct_l2, state_ct_r2 = state_ct_l2[3:-1], state_ct_r2[3:-1]

        # create the figure object
        columns = 1
        rows = 3
        fig = plt.figure(figsize=(fig_size[0], fig_size[1]))
        gs = gridspec.GridSpec(columns, rows)
        gs.update(hspace=0.5)

        ax = []
        for c in range(columns):
            ax.append([])
            for r in range(rows):
                ax[c].append(fig.add_subplot(gs[c, r]))

        # change the bin size here
        h_bins = np.arange(0,25,bin_size)

        # BOTH SIDES
        ax[0][0].hist(state_ct_l2, density='true', color='k', histtype='step')
        ax[0][0].hist(state_ct_r2, density='true', color='k', histtype='step')
        ax[0][0].hist(state_ct_l2, density='true', color='gray',
                    alpha=0.2, label='short choice port')
        ax[0][0].hist(state_ct_r2, density='true', color='k',
                    alpha=0.2, label='long choice port')
        ax[0][0].set(xlabel='time since initialization(s)', ylabel='P(breaking)')
        ax[0][0].spines['right'].set_visible(False)
        ax[0][0].spines['top'].set_visible(False)
        ax[0][0].yaxis.set_ticks_position('left')
        ax[0][0].xaxis.set_ticks_position('bottom')

        # LEFT BREAKING FIXATIONS 
        ax[0][1].hist(state_ct_l2, density='true', color='k', histtype='step')
        ax[0][1].hist(state_ct_l2, density='true', color='gray',
                    alpha=0.2, label='short choice port')
        ax[0][1].set(xlabel='time since initialization(s)', ylabel='P(breaking)')
        ax[0][1].spines['right'].set_visible(False)
        ax[0][1].spines['top'].set_visible(False)
        ax[0][1].yaxis.set_ticks_position('left')
        ax[0][1].xaxis.set_ticks_position('bottom')
        ax[0][1].legend()
        
        # RIGHT BREAKING FIXATIONS
        ax[0][2].hist(state_ct_r2, density='true', color='k', histtype='step')
        ax[0][2].hist(state_ct_r2, density='true', color='k',
                    alpha=0.2, label='long choice port')
        ax[0][2].set(xlabel='time since initialization(s)', ylabel='P(breaking)')
        ax[0][2].spines['right'].set_visible(False)
        ax[0][2].spines['top'].set_visible(False)
        ax[0][2].yaxis.set_ticks_position('left')
        ax[0][2].xaxis.set_ticks_position('bottom')
        ax[0][2].legend()

        #fig.savefig(save_plots +'.png', bbox_inches='tight', dpi=400)

        return fig

    def get_trial_identity_matrix(self, i_ep):
        # returns a matrix with collumns
        # trial index, second tone time, correct choice
        ttype_v = []
        trial_h = self.sim_data['trial_h'][i_ep:-1]
        for i, e in enumerate(np.unique(trial_h)):
            if i < np.unique(trial_h).size/2:
                ttype_v.append(
                    [e, int(self.param['second_tone_list'][int(e)]), 0])
            else:
                ttype_v.append(
                    [e, int(self.param['second_tone_list'][int(e)]), 1])

        return np.asarray(ttype_v).astype(int)

    def get_breaking_fixation_data_v2(self, sim_data, ep_range, st_idx):

        """This function outputs the time in seconds when the agent broke fixation for either left or right actions"""

        # first we get the data and identify the breaking fixations
        # only grabs the choices up until the states of the
        # last second tone
        i_st = st_idx[0]
        f_st = st_idx[1]
        
        i_ep = ep_range[0]
        f_ep = ep_range[1]
        
        dp_data = sim_data['behaviour_h'][i_ep:f_ep, i_st:f_st]

        # these two vectors contain 1s where a left or right action was chosen during the delay period
        # zeros otherwise
        bf_l = (dp_data == 0).astype(int)
        bf_r = (dp_data == 1).astype(int)

        # these two vectors contain the state where the choice was made for either left or right
        state_ct_l = []
        state_ct_r = []

        for e, d in zip(bf_l, bf_r):
            if np.where(e == 1)[0].size != 0:
                state_ct_l.append(np.where(e == 1)[0])
            if np.where(d == 1)[0].size != 0:
                state_ct_r.append(np.where(d == 1)[0])
        state_ct_l = np.asarray(state_ct_l).flatten()
        state_ct_r = np.asarray(state_ct_r).flatten()

        # create a temporal axis that goes from 0 to 2.5s to mimic the real data
        time_coor = np.linspace(0, 2.5, len(np.unique(state_ct_l)))
        uniq_st = np.unique(state_ct_l)

        # match the temporal index to time in seconds
        time_match = []
        for e, d in zip(time_coor, uniq_st):
            time_match.append([d, e])
        time_match = np.asarray(time_match)

        # now change the state indexes to temporal indexes in the
        # two vectors
        state_ct_l2 = []
        state_ct_r2 = []
        for e, f in zip(state_ct_l, state_ct_r):
            for d in time_match:
                if e == d[0]:
                    state_ct_l2.append(d[1])
                if f == d[0]:
                    state_ct_r2.append(d[1])
        state_ct_l2 = np.asarray(state_ct_l2)
        state_ct_r2 = np.asarray(state_ct_r2)

        # final vector contaning the time of breaking fixation in seconds
        return state_ct_l2, state_ct_r2, state_ct_l, state_ct_r

    def plot_breaking_fixations_v2(self, sim_data, ep_range, st_idx, n_bins, fig_size, vline_pos, time_bounds):
        
        i_st = st_idx[0]
        f_st = st_idx[1]
        
        i_ep = ep_range[0]
        f_ep = ep_range[1]
        
        # create the figure object
        columns = 1
        rows = 2
        fig = plt.figure(figsize = (fig_size[0], fig_size[1]))
        gs = gridspec.GridSpec(columns, rows)
        gs.update(hspace = 0.5)

        # defining the figure pannels
        ax = []
        for c in range(columns):
            ax.append([])
            for r in range(rows):
                ax[c].append(fig.add_subplot(gs[c, r]))

        bf_data = self.get_breaking_fixation_data_v2(sim_data, ep_range, [i_st, f_st])
        h_bins = np.linspace(i_st, f_st, n_bins)
        #print(bf_data, h_bins)
        
        ax[0][0].hist(bf_data[2], bins = h_bins, color = 'limegreen')
        ax[0][0].set_ylabel('Events')
        ax[0][0].set_xlabel('State')
        ax[0][0].set_title('BF Short')
        ax[0][0].spines['right'].set_visible(False)
        ax[0][0].spines['top'].set_visible(False)
        ax[0][0].yaxis.set_ticks_position('left')
        ax[0][0].xaxis.set_ticks_position('bottom')
        
        ax[0][1].hist(bf_data[3], bins = h_bins, color = 'mediumorchid', alpha = 0.7)
        ax[0][1].set_ylabel('Events')
        ax[0][1].set_xlabel('State')
        ax[0][1].set_title('BF Long')
        ax[0][1].spines['right'].set_visible(False)
        ax[0][1].spines['top'].set_visible(False)
        ax[0][1].yaxis.set_ticks_position('left')
        ax[0][1].xaxis.set_ticks_position('bottom')
        
        return fig

    def plot_breaking_fixations_single(self, sim_data, ep_range, st_idx, n_bins, fig_size, vline_pos, time_bounds):
    
        i_st = st_idx[0]
        f_st = st_idx[1]
        
        i_ep = ep_range[0]
        f_ep = ep_range[1]
        
        # create the figure object
        columns = 1
        rows = 1
        fig = plt.figure(figsize = (fig_size[0], fig_size[1]))
        gs = gridspec.GridSpec(columns, rows)
        gs.update(hspace = 0.5)

        # defining the figure pannels
        ax = []
        for c in range(columns):
            ax.append([])
            for r in range(rows):
                ax[c].append(fig.add_subplot(gs[c, r]))

        bf_data = self.get_breaking_fixation_data_v2(sim_data, ep_range, [i_st, f_st])
        h_bins = np.linspace(i_st, f_st, n_bins)
        #print(bf_data, h_bins)
        
        ax[0][0].hist(bf_data[2], bins = h_bins, color = 'k', density = True, histtype=u'step', linewidth = 2, alpha = 0.3)
        ax[0][0].hist(bf_data[2], bins = h_bins, color = 'silver', density = True, alpha = 0.3)
        ax[0][0].hist(bf_data[3], bins = h_bins, color = 'k', density = True, histtype=u'step', linewidth = 2, alpha = 0.5)
        ax[0][0].hist(bf_data[3], bins = h_bins, color = 'dimgrey', density = True, alpha = 0.5)

        ax[0][0].set_ylabel('Probability')
        ax[0][0].set_xlabel('Time in trial(s)')
        ax[0][0].set_title('Broken Fixations', size = 15)
        ax[0][0].spines['right'].set_visible(False)
        ax[0][0].spines['top'].set_visible(False)
        ax[0][0].yaxis.set_ticks_position('left')
        ax[0][0].xaxis.set_ticks_position('bottom')
        ax[0][0].axvline(vline_pos, color = 'k', linestyle = '--', linewidth = 0.5)
        #ax[0][0].set_yticks([0,0.03,0.06])
        #ax[0][0].set_yticklabels([0., '', 0.06]) # from the experiment
        
        time_i = time_bounds[0]
        time_m = time_bounds[1]
        time_f = time_bounds[2]
        ax[0][0].set_xticks([time_i,time_m,time_f])
        ax[0][0].set_xticklabels([0.6, 1.5, 2.4]) # from the experiment
        
        ax[0][0] = plt.gca()  # only to illustrate what `ax` is
        ax[0][0].autoscale(enable=True, axis='x', tight=True)
        
        
        return fig

    def plot_breaking_fixations_single_gp(self, sim_data, ep_range, st_idx, n_bins, fig_size, vline_pos, time_bounds):
    
        i_st = st_idx[0]
        f_st = st_idx[1]
        
        i_ep = ep_range[0]
        f_ep = ep_range[1]
        
        # create the figure object
        columns = 1
        rows = 1
        fig = plt.figure(figsize = (fig_size[0], fig_size[1]))
        gs = gridspec.GridSpec(columns, rows)
        gs.update(hspace = 0.5)

        # defining the figure pannels
        ax = []
        for c in range(columns):
            ax.append([])
            for r in range(rows):
                ax[c].append(fig.add_subplot(gs[c, r]))

        bf_data = self.get_breaking_fixation_data_v2(sim_data, ep_range, [i_st, f_st])
        h_bins = np.linspace(i_st, f_st, n_bins)
        #print(bf_data, h_bins)
        
        ax[0][0].hist(bf_data[2], bins = h_bins, color = 'k', density = True, histtype = u'step', linewidth = 2, alpha = 0.6)
        ax[0][0].hist(bf_data[2], bins = h_bins, color = 'limegreen', density = True, alpha = 0.7)
        ax[0][0].hist(bf_data[3], bins = h_bins, color = 'k', density = True, histtype = u'step', linewidth = 2, alpha = 0.6)
        ax[0][0].hist(bf_data[3], bins = h_bins, color = 'mediumorchid', density = True, alpha = 0.7)

        ax[0][0].set_ylabel('Probability')
        ax[0][0].set_xlabel('Time in trial(s)')
        ax[0][0].set_title('Broken Fixations', size = 15)
        ax[0][0].spines['right'].set_visible(False)
        ax[0][0].spines['top'].set_visible(False)
        ax[0][0].yaxis.set_ticks_position('left')
        ax[0][0].xaxis.set_ticks_position('bottom')
        ax[0][0].axvline(vline_pos, color = 'k', linestyle = '--', linewidth = 0.5)
        #ax[0][0].set_yticks([0,0.03,0.06])
        #ax[0][0].set_yticklabels([0., '', 0.06]) # from the experiment
        
        time_i = time_bounds[0]
        time_m = time_bounds[1]
        time_f = time_bounds[2]
        ax[0][0].set_xticks([time_i,time_m,time_f])
        ax[0][0].set_xticklabels([0.6, 1.5, 2.4]) # from the experiment
        
        ax[0][0] = plt.gca()  # only to illustrate what `ax` is
        ax[0][0].autoscale(enable=True, axis='x', tight=True)
        
        
        return fig

    def plot_psychometric_v2(self, sim_data, param, fig_size, ep_range, st_idx, tone_states, init_cond, time_bounds, point_selection):

        # psychometric function
        def pf(x, alpha, beta):
            return 1. / (1 + np.exp( -(x-alpha)/beta ))

        # PSYCHOMETRIC FUNCTION
        dp_data2 = sim_data['behaviour_h']
        n_eps = dp_data2.shape[0]
        i_st = st_idx[0]
        f_st = st_idx[1]
        time_i = time_bounds[0]
        time_m = time_bounds[1]
        time_f = time_bounds[2]
        
        i_ep = ep_range[0]
        f_ep = ep_range[1]
        
        long_ch = np.sum((dp_data2[i_ep:f_ep,i_st:f_st]==1).astype(int), axis = 0)
        short_ch = np.sum((dp_data2[i_ep:f_ep,i_st:f_st]==0).astype(int), axis = 0)
        
        # psychometric curve fitting
        d1 = np.arange(i_st, f_st)
        p1 = np.nan_to_num(long_ch/(long_ch+short_ch))
        d3 = np.linspace(0, f_st-i_st, num = len(p1), dtype = int32)
        
        p2 = p1[point_selection]
        d4 = d3[point_selection]
        
        print('p1', p1)
        print('d4', d4)
        print('p2', p2)
        
        # fitting
        par0 = np.array([0.01, 1.]) # initial conditions of the fit
        par, mcov = curve_fit(pf, d4, p2, par0)
        #d2 = np.linspace(i_st, f_st, 50)
        
        # create the figure object
        columns = 1
        rows = 1
        fig = plt.figure(figsize=(fig_size[0], fig_size[1]))
        gs = gridspec.GridSpec(columns, rows)
        gs.update(hspace=0.5)
        

        # definig the figure pannels
        ax = []
        for c in range(columns):
            ax.append([])
            for r in range(rows):
                ax[c].append(fig.add_subplot(gs[c, r]))

        
        ax[0][0].plot(d3, pf(d3, par[0], par[1]), 'silver', linewidth = 2)        
        ax[0][0].plot(d3[point_selection], p1[point_selection], 'ko')
        ax[0][0].set_title('Choice Behavior', size = 15)
        ax[0][0].set_ylabel('P(Long choice)')
        ax[0][0].set_xlabel('Time interval(s)')
        ax[0][0].spines['right'].set_visible(False)
        ax[0][0].spines['top'].set_visible(False)
        #ax[0][0].set_title(r'$\beta$ = ' + str(param['beta']) + 
        #                   r', $\gamma$ = ' + str(param['gamma']) + 
        #                   r', $\sigma_1$ = ' + str(param['obs_var'][0]) + 
        #                   r', $\sigma_2$ = ' + str(param['obs_var'][1]) + 
        #                   r', $\sigma_3$ = ' + str(param['obs_var'][2]), size = 12) 
        
        ax[0][0].set_xticks([time_i,time_m,time_f])
        ax[0][0].set_xticklabels([0.6, 1.5, 2.4]) # from the experiment
        
        ax[0][0].set_yticks([0,0.5,1])
        ax[0][0].set_yticklabels([0, '', 1]) # from the experiment
        
        ax[0][0].axvline(time_m, color = 'silver', linestyle =  'dashed', linewidth = 2, alpha = 0.4)
        ax[0][0].axhline(0.5, color = 'silver', linestyle =  'dashed', linewidth = 2, alpha = 0.4)
        
        
        
        return fig

    def plot_bulk_delayperiod(self, sim_data, param, fig_size, last_second_tone, time_bounds):
    
        """
        Plotting for a single simulation
        """
        A = sim_data['A']
        Ac = sim_data['Ac']
        last_stl = param['second_tone_list'][-1]
        env_size = int(param['n_states'] * 2)

        # choose only the delay period states
        idx = np.linspace(0,last_second_tone, last_second_tone).astype(int)

        # create the figure object
        columns = 1
        rows = 3
        fig = plt.figure(figsize=(fig_size[0], fig_size[1]))
        gs = gridspec.GridSpec(columns, rows)
        gs.update(hspace=0.5)

        ax = []
        for c in range(columns):
            ax.append([])
            for r in range(rows):
                ax[c].append(fig.add_subplot(gs[c, r]))

        time_i = time_bounds[0]
        time_m = time_bounds[1]
        time_f = time_bounds[2]
        
        ax[0][0].plot(A[0, idx, 1], 'b', label='D1',  linewidth = 3)
        ax[0][0].plot(A[1, idx, 1], 'r', label='A2A',  linewidth = 3)
        ax[0][0].legend()
        ax[0][0].set_title('Contra-long', size = 15)
        ax[0][0].set_xlabel('Time in trial (s)')
        ax[0][0].set_ylabel('Advantage')
        ax[0][0].spines['right'].set_visible(False)
        ax[0][0].spines['top'].set_visible(False)
        ax[0][0].yaxis.set_ticks_position('left')
        ax[0][0].xaxis.set_ticks_position('bottom')
        ax[0][0].set_xticks([time_i,time_m,time_f])
        ax[0][0].set_xticklabels([0.6, 1.5, 2.4]) # from the experiment
        #ax[0][0].axvline(time_m, color = 'k', linestyle =  '--', linewidth = 0.5)
        #ax[0][0].axhline(0.5, color = 'k', linestyle =  '--', linewidth = 0.5)
        ax[0][0].set_yticks([-4,-2, 0, 2, 4])
        ax[0][0].set_yticklabels([4,'', 0, '', 4]) # from the experiment
        
        ax[0][1].set_xticks([time_i,time_m,time_f])
        ax[0][1].set_xticklabels([0.6, 1.5, 2.4]) # from the experiment
        ax[0][1].plot(A[0, idx, 0], 'b',  linewidth = 3)
        ax[0][1].plot(A[1, idx, 0], 'r',  linewidth = 3)
        ax[0][1].set_title('Contra-short', size = 15)
        ax[0][1].set_xlabel('Time in trial(s)')
        ax[0][1].set_ylabel('Advantage')
        ax[0][1].spines['right'].set_visible(False)
        ax[0][1].spines['top'].set_visible(False)
        ax[0][1].yaxis.set_ticks_position('left')
        ax[0][1].xaxis.set_ticks_position('bottom')
        ax[0][1].set_xticks([time_i,time_m,time_f])
        ax[0][1].set_xticklabels([0.6, 1.5, 2.4]) # from the experiment
        #ax[0][1].axvline(time_m, color = 'k', linestyle =  'dashed', linewidth = 2, alpha = 0.7)
        #ax[0][1].axhline(0.5, color = 'k', linestyle =  'dashed', linewidth = 2, alpha = 0.7)
        ax[0][1].set_yticks([-4,-2, 0, 2, 4])
        ax[0][1].set_yticklabels([4,'', 0, '', 4]) # from the experiment
        
        ax[0][2].set_xticks([time_i,time_m,time_f])
        ax[0][2].set_xticklabels([0.6, 1.5, 2.4]) # from the experiment
        ax[0][2].plot(Ac[idx[1:-1], 0], 'forestgreen', label='CS', linewidth = 3)
        ax[0][2].plot(Ac[idx[1:-1], 1], 'darkviolet', label='CL', linewidth = 3)
        ax[0][2].legend()
        ax[0][2].set_xlabel('Time in trial (s)')
        ax[0][2].set_ylabel('Advantage')
        ax[0][2].spines['right'].set_visible(False)
        ax[0][2].spines['top'].set_visible(False)
        ax[0][2].yaxis.set_ticks_position('left')
        ax[0][2].xaxis.set_ticks_position('bottom')
        ax[0][2].set_xticks([time_i,time_m+1,time_f+2])
        ax[0][2].set_xticklabels([0.6, 1.5, 2.4]) # from the experiment
        #ax[0][2].axvline(time_m+1, color = 'k', linestyle =  'dashed', linewidth = 2, alpha = 0.7)
        #ax[0][2].axhline(0.5, color = 'k', linestyle =  'dashed', linewidth = 2, alpha = 0.7)
        ax[0][2].set_yticks([-2, 1, 0, 1, 2])
        ax[0][2].set_yticklabels([-2, '', 0, '', 2]) # from the experiment
        ax[0][2].set_title('Dorso-medial signal', size = 15)

        return fig



    # UPDATE - 2C4A -- ALL FUNCTIONS BELOW ARE CURRENTLY BEING USED
    # CHECK WHICH FUNCTIONS ABOVE HAVE BEEN DEPRECATED

    # PLOTTING 


    def grid_plot_training_2C3A(self, fig_size, model_name, sim_data, tf_m, param, init_f, n_bins):
    
        fig = plt.figure(constrained_layout=True, figsize = (fig_size[0],fig_size[1]))
        fig.suptitle(model_name + ' - ' r'Training Parameters:'+r'$N_s = $'+ str(param['n_states'])+r' $N_{eps} = $'+str(param['n_episodes'])+r' $\gamma_v = $'+str(param['gamma_v'])+r' $\gamma_{dm} = $'+str(param['gamma_dm'])+r' $\beta = $'+str(param['beta'])+r' $\omega_c = $'+str(param['omega'][2]) , fontsize=16, y=1.05)

        gs = fig.add_gridspec(5, 4)

        f_list = [] 

        # DEFINING LOCATIONS OF THE FIGURES IN THE GRID PLOT
        
        f_list.append(fig.add_subplot(gs[0, 0])) #0 - psycho
        f_list.append(fig.add_subplot(gs[0, 1])) #1 - bf left
        f_list.append(fig.add_subplot(gs[0, 2])) #2 - bf right
        f_list.append(fig.add_subplot(gs[0, 3])) #3 -  transfer
        
        f_list.append(fig.add_subplot(gs[1, :-2])) #4 - v1
        f_list.append(fig.add_subplot(gs[1, 2])) #5 - v2
        f_list.append(fig.add_subplot(gs[1, 3])) #6 - v2
        
        f_list.append(fig.add_subplot(gs[2, :-2])) #7 - A left 
        f_list.append(fig.add_subplot(gs[2, -2:])) #8 - A right
        
        f_list.append(fig.add_subplot(gs[3, :-2])) #9 - policy
        f_list.append(fig.add_subplot(gs[3, 2])) #10 - Ac
        f_list.append(fig.add_subplot(gs[3, 3])) #11 - hazard

        f_list.append(fig.add_subplot(gs[4, 0])) #12 - conv A
        f_list.append(fig.add_subplot(gs[4, 1])) #14 - conv Ac
        f_list.append(fig.add_subplot(gs[4, -2:])) #15 - state visit
        
        # removing top and right axis
        for f in f_list:
            f.spines['right'].set_visible(False)
            f.spines['top'].set_visible(False)
        
        # PSYCHOMETRIC 
        i_ep = int(param['n_episodes'] * init_f)
        ep_range = [i_ep , param['n_episodes']]
        rt_st_v = self.get_real_time_state_vec(tf_m, param)
        #rt_st_v = self.get_real_time_state_vec_v2(tf_m) # this version of the function has jitter
        #rt_st_v = self.get_real_time_state_vec_v3(tf_m, 0.01) # this version of the function has jitter
        choice_per_state = self.get_choices_per_state(sim_data, ep_range)
        trial_subset = False
        
        ps_data = self.get_psychometric_data(sim_data, param, choice_per_state, rt_st_v, trial_subset, n_bins)
        bf_data = self.get_breaking_fixation_data(sim_data, choice_per_state, rt_st_v, n_bins)
        t_vec, par, mcov  = self.get_psychometric(ps_data[3], ps_data[4])


        f_list[0].plot(t_vec, self.pf(t_vec, par[0], par[1]), 'silver', linewidth = 2, color = 'k')        
        f_list[0].scatter(ps_data[3], ps_data[4], color = 'grey')
        f_list[0].set_ylabel('P(Long)')
        f_list[0].set_xlabel('Time (s)')
        f_list[0].axvline(1.5, color = 'k', linewidth = 0.5) 
        f_list[0].axhline(0.5, color = 'k', linewidth = 0.5)
        
        # BROKEN FIXATIONS 
        
        f_list[1].hist(bf_data[1], bf_data[0], color = 'green')
        f_list[1].set_ylabel('P(Br|CS)')
        f_list[1].set_xlabel('Time (s)')
        f_list[1].axvline(1.5, color = 'k', linewidth = 0.5) 

        f_list[2].hist(bf_data[2], bf_data[0], color = 'purple')
        f_list[2].set_ylabel('P(Br|CL)')
        f_list[2].set_xlabel('Time (s)')
        f_list[2].axvline(1.5, color = 'k', linewidth = 0.5) 

        # TRANSFER FUNCTION 
        
        f_list[3].plot(sim_data['tf_vec'][0], sim_data['tf_vec'][1], 'b')
        f_list[3].plot(sim_data['tf_vec'][0], sim_data['tf_vec'][2], 'g')
        f_list[3].plot(sim_data['tf_vec'][0], sim_data['tf_vec'][3], 'r')
        f_list[3].axhline(0, color = 'k', linewidth = 0.5)
        f_list[3].axvline(0, color = 'k', linewidth = 0.5) 
        f_list[3].set_ylabel(r'$f^p(\delta)$')
        f_list[3].set_xlabel(r'$\delta_t$')
        
        # STATE VALUE FUNCTION
        
        f_list[4].plot(sim_data['V'], 'k')
        f_list[4].set_xlabel('State')
        f_list[4].set_ylabel('V(s)')
        
        f_list[5].plot(sim_data['Vc'][0:param['n_states']], 'k')
        f_list[5].set_xlabel('State')
        f_list[5].set_ylabel(r'$V_{DM}(s)$')
        
        filtered_dV = sp.ndimage.filters.gaussian_filter1d(sim_data['diffV'], 500)
        f_list[6].plot(self.normalise_vec(filtered_dV), 'orange')
        f_list[6].set_xlabel('Eps')
        f_list[6].set_ylabel(r'$\Delta V(s)$')

        
        # ACTION PREFERENCE LEFT
        
        f_list[7].plot(sim_data['A'][0, :, 0], 'b') # direct
        f_list[7].plot(sim_data['A'][1, :, 0], 'r') # indirect
        f_list[7].axvline(sim_data['V'].shape[0]/2, color = 'k', linewidth = 0.5)
        f_list[7].set_xlabel('State')
        f_list[7].set_ylabel('A(S,Left)')

        # ACTION PREFERENCE RIGHT
        
        f_list[8].plot(sim_data['A'][0, :, 1], 'b')
        f_list[8].plot(sim_data['A'][1, :, 1], 'r')
        f_list[8].axvline(sim_data['V'].shape[0]/2, color = 'k', linewidth = 0.5)
        f_list[8].set_xlabel('State')
        f_list[8].set_ylabel('A(S,Right)')
        
        # ACT - POLICY
        mid_st = int(sim_data['V'].shape[0]/2)
        
        ADL = sim_data['A'][0,:,0]
        ADR = sim_data['A'][0,:,1]
        AIL = sim_data['A'][1,:,0]
        AIR = sim_data['A'][1,:,1]
        AML = sim_data['Ac'][:,0]   
        AMR = sim_data['Ac'][:,1]  
        ActL = ADL-AIL+AML
        ActR = ADR-AIR+AMR
        
        f_list[9].plot(ActL, 'g', label='Act L')
        f_list[9].plot(ActR, 'r', label='Act R')
        f_list[9].axvline(mid_st, color = 'k', linewidth = 0.5)
        f_list[9].legend()
        f_list[9].set_xlabel('State')
        f_list[9].set_ylabel('Act(s)')
        f_list[9].spines['right'].set_visible(False)
        f_list[9].spines['top'].set_visible(False)
        
        # ACTION PREFERENCE 3RD PATHWAY
        
        f_list[10].plot(sim_data['Ac'][:, 0][0:param['n_states']], 'g')
        f_list[10].plot(sim_data['Ac'][:, 1][0:param['n_states']], 'purple')
        f_list[10].set_xlabel('State')
        f_list[10].set_ylabel(r'$A^{DM}$(S,Right)')
        
        
        # CONVERGENCE ACTION PREFERENCES
        
        filtered_dA = np.zeros(sim_data['diffA'].shape)
        diffA = sim_data['diffA']
        for p in range(2):
            for a in range(3):
                filtered_dA[:, p, a] = sp.ndimage.filters.gaussian_filter1d(diffA[:,p,a], 500)

        for p in range(2):    
            for a in [0,1]:
                f_list[14].plot(self.normalise_vec(filtered_dA[:, p, a]), label=str(p)+','+str(a))
        f_list[14].legend()
        f_list[14].set_ylabel(r'$\Delta A^p(s,a)$')

        filtered_dAc = np.zeros(sim_data['diffAc'].shape)
        diffAc = sim_data['diffAc']
        for a in range(3):
            filtered_dAc[:, a] = sp.ndimage.filters.gaussian_filter1d(diffAc[:, a], 500)

        for a in [0,1]:
            f_list[11].plot(self.normalise_vec(filtered_dA[:, 0, a]), label=str(a))
        f_list[11].legend()
        f_list[11].set_xlabel('Episodes')
        f_list[11].set_ylabel(r'$\Delta A^{DM}(s,a)$')
        
        haz = self.calculate_hazard(sim_data, param, 0, n_bins, trial_subset, init_f, tf_m)

        f_list[12].plot(haz[0],haz[2], 'g')
        f_list[12].plot(haz[0],haz[3], 'purple')
        f_list[12].axvline(1.5, color = 'k')
        f_list[12].set_ylabel('Hazard (s)')
        f_list[12].set_xlabel('Time (s)')
        
        # STATE VISITS
        
        f_list[13].plot(self.normalise_vec(sim_data['state_visits'][param['n_states']:-1]), 'green')
        f_list[13].set_xlabel('State')
        f_list[13].set_ylabel('State Visits')
        

        return fig

    def grid_plot_training_2C4A(self,fig_size, model_name, sim_data, param, tf_m, init_f, n_bins):
    
        fig = plt.figure(constrained_layout=True, figsize = (fig_size[0],fig_size[1]))
        fig.suptitle(model_name + ' - ' r'Training Parameters:'+r'$N_s = $'+ str(param['n_states'])+r' $N_{eps} = $'+str(param['n_episodes'])+r' $\gamma_v = $'+str(param['gamma_v'])+r' $\gamma_{dm} = $'+str(param['gamma_dm'])+r' $\beta = $'+str(param['beta'])+r' $\omega_c = $'+str(param['omega'][2]) , fontsize=16, y=1.05)

        gs = fig.add_gridspec(6, 4)

        f_list = [] 

        # DEFINING LOCATIONS OF THE FIGURES IN THE GRID PLOT
        
        f_list.append(fig.add_subplot(gs[0, 0])) #0 - psycho
        f_list.append(fig.add_subplot(gs[0, 1])) #1 - bf left
        f_list.append(fig.add_subplot(gs[0, 2])) #2 - bf right
        f_list.append(fig.add_subplot(gs[0, 3])) #3 -  transfer
        
        f_list.append(fig.add_subplot(gs[1, :-2])) #4 - v1
        f_list.append(fig.add_subplot(gs[1, 2])) #5 - v2
        f_list.append(fig.add_subplot(gs[1, 3])) #6 - v2
        
        f_list.append(fig.add_subplot(gs[2, :-2])) #7 - A left 
        f_list.append(fig.add_subplot(gs[2, -2:])) #8 - A right
        
        f_list.append(fig.add_subplot(gs[3, :-2])) #9 - Ac left 
        f_list.append(fig.add_subplot(gs[3, -2:])) #10 - Ac right
        
        f_list.append(fig.add_subplot(gs[4, :-2])) #11 - Act - policy
        f_list.append(fig.add_subplot(gs[4, -2:])) #12 - conv A
        
        f_list.append(fig.add_subplot(gs[5, 0])) #13 - hazard
        f_list.append(fig.add_subplot(gs[5, 1])) #14 - state visits
        f_list.append(fig.add_subplot(gs[5, -2:])) #15 - conv Ac
        
        # removing top and right axis
        for f in f_list:
            f.spines['right'].set_visible(False)
            f.spines['top'].set_visible(False)
        
        # PSYCHOMETRIC 
        i_ep = int(param['n_episodes'] * init_f)
        ep_range = [i_ep , param['n_episodes']]
        rt_st_v = self.get_real_time_state_vec(tf_m, param)
        choice_per_state = self.get_choices_per_state(sim_data, ep_range)
        trial_subset = False
        ps_data = self.get_psychometric_data(sim_data, param, choice_per_state, rt_st_v, trial_subset, n_bins)
        bf_data = self.get_breaking_fixation_data(sim_data, choice_per_state, rt_st_v, n_bins)
        t_vec, par, mcov  = self.get_psychometric(ps_data[3], ps_data[4])


        f_list[0].plot(t_vec, self.pf(t_vec, par[0], par[1]), 'silver', linewidth = 2, color = 'k')        
        f_list[0].scatter(ps_data[3], ps_data[4], color = 'grey')
        f_list[0].set_ylabel('P(Long)')
        f_list[0].set_xlabel('Time (s)')
        f_list[0].axvline(1.5, color = 'k', linewidth = 0.5) 
        f_list[0].axhline(0.5, color = 'k', linewidth = 0.5)
        
        # BROKEN FIXATIONS 
        
        f_list[1].hist(bf_data[1], bf_data[0], color = 'green')
        f_list[1].set_ylabel('P(Br|CS)')
        f_list[1].set_xlabel('Time (s)')
        f_list[1].axvline(1.5, color = 'k', linewidth = 0.5) 

        f_list[2].hist(bf_data[2], bf_data[0], color = 'purple')
        f_list[2].set_ylabel('P(Br|CL)')
        f_list[2].set_xlabel('Time (s)')
        f_list[2].axvline(1.5, color = 'k', linewidth = 0.5) 

        # TRANSFER FUNCTION 
        
        f_list[3].plot(sim_data['tf_vec'][0], sim_data['tf_vec'][1], 'b')
        #f_list[3].plot(sim_data['tf_vec'][0], sim_data['tf_vec'][2], 'g')
        f_list[3].plot(sim_data['tf_vec'][0], sim_data['tf_vec'][3], 'r')
        f_list[3].axhline(0, color = 'k', linewidth = 0.5)
        f_list[3].axvline(0, color = 'k', linewidth = 0.5) 
        f_list[3].set_ylabel(r'$f^p(\delta)$')
        f_list[3].set_xlabel(r'$\delta_t$')
        
        # STATE VALUE FUNCTION
        
        f_list[4].plot(sim_data['V'], 'k')
        f_list[4].set_xlabel('State')
        f_list[4].set_ylabel('V(s)')
        
        f_list[5].plot(sim_data['Vc'][0:param['n_states']], 'k')
        f_list[5].set_xlabel('State')
        f_list[5].set_ylabel(r'$V_{DM}(s)$')
        
        filtered_dV = sp.ndimage.filters.gaussian_filter1d(sim_data['diffV'], 500)
        f_list[6].plot(self.normalise_vec(filtered_dV), 'orange')
        f_list[6].set_xlabel('Eps')
        f_list[6].set_ylabel(r'$\Delta V(s)$')

        
        # ACTION PREFERENCE LEFT DLS
        
        f_list[7].plot(sim_data['A'][0, :, 0], 'b') # direct
        f_list[7].plot(sim_data['A'][1, :, 0], 'r') # indirect
        f_list[7].axvline(sim_data['V'].shape[0]/2, color = 'k', linewidth = 0.5)
        f_list[7].set_xlabel('State')
        f_list[7].set_ylabel('A(S,Left)')

        # ACTION PREFERENCE RIGHT DLS
        
        f_list[8].plot(sim_data['A'][0, :, 1], 'b')
        f_list[8].plot(sim_data['A'][1, :, 1], 'r')
        f_list[8].axvline(sim_data['V'].shape[0]/2, color = 'k', linewidth = 0.5)
        f_list[8].set_xlabel('State')
        f_list[8].set_ylabel('A(S,Right)')
        
        # ACTION PREFERENCE LEFT DMS
        
        f_list[9].plot(sim_data['Ac'][0, :, 0], 'b') # direct
        f_list[9].plot(sim_data['Ac'][1, :, 0], 'r') # indirect
        f_list[9].axvline(sim_data['V'].shape[0]/2, color = 'k', linewidth = 0.5)
        f_list[9].set_xlabel('State')
        f_list[9].set_ylabel('A(S,Left)')

        # ACTION PREFERENCE RIGHT DMS
        
        f_list[10].plot(sim_data['Ac'][0, :, 1], 'b')
        f_list[10].plot(sim_data['Ac'][1, :, 1], 'r')
        f_list[10].axvline(sim_data['V'].shape[0]/2, color = 'k', linewidth = 0.5)
        f_list[10].set_xlabel('State')
        f_list[10].set_ylabel('A(S,Right)')
        
        # ACT - POLICY
        mid_st = int(sim_data['V'].shape[0]/2)
        
        ADL = sim_data['A'][0,:,0]
        ADR = sim_data['A'][0,:,1]
        AIL = sim_data['A'][1,:,0]
        AIR = sim_data['A'][1,:,1]
        AMDR = sim_data['Ac'][0,:,0]   
        AMDL = sim_data['Ac'][0,:,1]   
        AMIR = sim_data['Ac'][1,:,0]   
        AMIL = sim_data['Ac'][1,:,1]   
        ActL = ADL-AIL+AMDL-AMIL
        ActR = ADR-AIR+AMDR-AMIR
        
        f_list[11].plot(ActL, 'g', label='Act L')
        f_list[11].plot(ActR, 'r', label='Act R')
        f_list[11].axvline(mid_st, color = 'k', linewidth = 0.5)
        f_list[11].legend()
        f_list[11].set_xlabel('State')
        f_list[11].set_ylabel('Act(s)')
        f_list[11].spines['right'].set_visible(False)
        f_list[11].spines['top'].set_visible(False)
        
        # CONVERGENCE ACTION PREFERENCES
        
        filtered_dA = np.zeros(sim_data['diffA'].shape)
        diffA = sim_data['diffA']
        for p in range(2):
            for a in range(3):
                filtered_dA[:, p, a] = sp.ndimage.filters.gaussian_filter1d(diffA[:,p,a], 500)

        for p in range(2):    
            for a in [0,1]:
                f_list[12].plot(self.normalise_vec(filtered_dA[:, p, a]), label=str(p)+','+str(a))
        f_list[12].legend()
        f_list[12].set_ylabel(r'$\Delta A^p(s,a)$')

        filtered_dAc = np.zeros(sim_data['diffAc'].shape)
        diffAc = sim_data['diffAc']
        for p in range(2):
            for a in range(3):
                filtered_dAc[:, p, a] = sp.ndimage.filters.gaussian_filter1d(diffAc[:,p,a], 500)

        for p in range(2):    
            for a in [0,1]:
                f_list[15].plot(self.normalise_vec(filtered_dAc[:, p, a]), label=str(p)+','+str(a))
        f_list[15].legend()
        f_list[15].set_xlabel('Episodes')
        f_list[15].set_ylabel(r'$\Delta A^{DM}(s,a)$')
        

        haz = self.calculate_hazard(sim_data, param, 0, n_bins, trial_subset, init_f, tf_m)

        f_list[13].plot(haz[0],haz[2], 'g')
        f_list[13].plot(haz[0],haz[3], 'purple')
        f_list[13].axvline(1.5, color = 'k')
        f_list[13].set_ylabel('Hazard (s)')
        f_list[13].set_xlabel('Time (s)')
        
        # STATE VISITS
        
        f_list[14].plot(self.normalise_vec(sim_data['state_visits'][param['n_states']:-1]), 'green')
        f_list[14].set_xlabel('State')
        f_list[14].set_ylabel('State Visits')
        

        return fig

    def grid_plot_test(self,fig_size, model_name, sim_data, param, tf_m, init_f, n_bins, sample_noise, trial_subset):
    
        fig = plt.figure(constrained_layout=True, figsize = (fig_size[0],fig_size[1]))
        fig.suptitle(model_name + ' - ' r'Testing Parameters:'+r'$N_s = $'+ str(param['n_states'])+r' $N_{eps} = $'+str(sim_data['n_episodes'])+r' $\gamma_v = $'+str(param['gamma_v'])+r' $\gamma_{dm} = $'+str(param['gamma_dm'])+r' $\beta = $'+str(tf_m.beta)+r' $\omega_c = $'+str(tf_m.w_CD)+' '+str(tf_m.w_CI), fontsize=16, y=1.05)

        gs = fig.add_gridspec(5, 4)

        f_list = [] 

        # DEFINING LOCATIONS OF THE FIGURES IN THE GRID PLOT
        
        f_list.append(fig.add_subplot(gs[0, 0])) #0 - psycho
        f_list.append(fig.add_subplot(gs[0, 1])) #1 - bf left
        f_list.append(fig.add_subplot(gs[0, 2])) #2 - bf right
        f_list.append(fig.add_subplot(gs[0, 3])) #2 - bf right
        
        # removing top and right axis
        for f in f_list:
            f.spines['right'].set_visible(False)
            f.spines['top'].set_visible(False)
            
        ep_range = [0, tf_m.n_test_episodes]
        rt_st_v = self.get_real_time_state_vec(tf_m, param)

        # HARDCODED VARIABLE HANGING AROUND --------------
        n_bins = 10
        choice_per_state = self.get_choices_per_state(sim_data, ep_range)
        ps_data = self.get_psychometric_data(sim_data, param, choice_per_state, rt_st_v, trial_subset, n_bins)
        bf_data = self.get_breaking_fixation_data(sim_data, choice_per_state, rt_st_v, n_bins)
        t_vec, par, mcov  = self.get_psychometric(ps_data[3], ps_data[4])

        f_list[0].plot(t_vec, self.pf(t_vec, par[0], par[1]), 'silver', linewidth = 2, color = 'k')        
        f_list[0].scatter(ps_data[3], ps_data[4], color = 'grey')
        f_list[0].set_ylabel('P(Long)')
        f_list[0].set_xlabel('Time (s)')
        f_list[0].axvline(1.5, color = 'k', linewidth = 0.5) 
        f_list[0].axhline(0.5, color = 'k', linewidth = 0.5)
        
        # BROKEN FIXATIONS 
        
        f_list[1].hist(bf_data[1], bf_data[0], color = 'green')
        f_list[1].set_ylabel('P(Br|CS)')
        f_list[1].set_xlabel('Time (s)')
        f_list[1].axvline(1.5, color = 'k', linewidth = 0.5) 

        f_list[2].hist(bf_data[2], bf_data[0], color = 'purple')
        f_list[2].set_ylabel('P(Br|CL)')
        f_list[2].set_xlabel('Time (s)')
        f_list[2].axvline(1.5, color = 'k', linewidth = 0.5) 
        
        # HAZARD
        haz = self.calculate_hazard(sim_data, param, 1, n_bins, trial_subset, init_f, tf_m)

        f_list[3].plot(haz[0],haz[2], 'g')
        f_list[3].plot(haz[0],haz[3], 'purple')
        f_list[3].axvline(1.5, color = 'k')
        f_list[3].set_ylabel('Hazard (s)')
        f_list[3].set_xlabel('Time (s)')

        return fig

    def grid_plot_pert(self,fig_size, model_name, sim_data, param, tf_m, init_f, n_bins, pert_mag, trial_subset):
    
        fig = plt.figure(constrained_layout=True, figsize = (fig_size[0],fig_size[1]))
        fig.suptitle(model_name + ' - ' r'Parameters:'+r'$N_s = $'+ str(param['n_states'])+r' $N_{eps} = $'+str(tf_m.n_test_episodes)+r' $\beta = $'+str(tf_m.beta)+r'PERT_MAG'+str(pert_mag) , fontsize=16, y=1.05)

        gs = fig.add_gridspec(5, 4)

        f_list = [] 

        # DEFINING LOCATIONS OF THE FIGURES IN THE GRID PLOT
        
        f_list.append(fig.add_subplot(gs[0, 0])) #0 - haz
        f_list.append(fig.add_subplot(gs[0, 1])) #1 - bf left
        f_list.append(fig.add_subplot(gs[0, 2])) #2 - bf righ0
        
        # removing top and right axis
        for f in f_list:
            f.spines['right'].set_visible(False)
            f.spines['top'].set_visible(False)
        
        # BROKEN FIXATIONS 
        
        ep_range = [0, tf_m.n_test_episodes]
        rt_st_v = self.get_real_time_state_vec(tf_m, param)
        #rt_st_v = self.get_real_time_state_vec_v3(tf_m, 0.01)
        choice_per_state = self.get_choices_per_state(sim_data, ep_range)
        bf_data = self.get_breaking_fixation_data(sim_data, choice_per_state, rt_st_v, n_bins)
        
        f_list[0].hist(bf_data[1], bf_data[0], color = 'green')
        f_list[0].set_ylabel('P(Br|CS)')
        f_list[0].set_xlabel('Time (s)')
        f_list[0].axvline(1.5, color = 'k', linewidth = 0.5) 

        f_list[1].hist(bf_data[2], bf_data[0], color = 'purple')
        f_list[1].set_ylabel('P(Br|CL)')
        f_list[1].set_xlabel('Time (s)')
        f_list[1].axvline(1.5, color = 'k', linewidth = 0.5) 
        
        # HAZARD
        n_bins = 10
        #haz = self.calculate_hazard(sim_data, param, test, n_bins, trial_subset, init_f, tf_m)
        haz = self.calculate_hazard(sim_data, param, 0, n_bins, trial_subset, init_f, tf_m)

        f_list[2].plot(haz[0],haz[2], 'g')
        f_list[2].plot(haz[0],haz[3], 'purple')
        f_list[2].axvline(1.5, color = 'k')
        f_list[2].set_ylabel('Hazard (s)')
        f_list[2].set_xlabel('Time (s)')

        return fig

    def grid_plot_neural_activity_DMS(self, fig_size, sim_data, n_timepoints, tf_m):

        fig = plt.figure(constrained_layout=True, figsize = (fig_size[0],fig_size[1]))
        #fig.suptitle('Sampled Action Preferences', fontsize=16, y=1.02)

        gs = fig.add_gridspec(1, 2)

        f_list = [] 

        # DEFINING LOCATIONS OF THE FIGURES IN THE GRID PLOT
        
        f_list.append(fig.add_subplot(gs[0, 0])) #0 - haz
        f_list.append(fig.add_subplot(gs[0, 1])) #1 - bf left
        
        # removing top and right axis
        for f in f_list:
            f.spines['right'].set_visible(False)
            f.spines['top'].set_visible(False)
        
        # sample the data
        sA = self.sample_action_preferences_DMS(sim_data, n_timepoints, tf_m)
        
        f_list[0].plot(sA[0], np.mean(sA[1][0,0,:],axis = 0),'b')
        f_list[0].plot(sA[0], np.mean(sA[1][1,0,:],axis = 0),'r')
        f_list[0].set_ylabel(r'$A_{DMS}^{D,I}(CS)$')
        f_list[0].set_xlabel('Time (s)')
        f_list[0].axvline(1.5, color = 'k', linewidth = 0.5) 

        f_list[1].plot(sA[0], np.mean(sA[1][0,1,:],axis = 0),'b')
        f_list[1].plot(sA[0], np.mean(sA[1][1,1,:],axis = 0),'r')
        f_list[1].set_ylabel(r'$A_{DMS}^{D,I}(CL)$')
        f_list[1].set_xlabel('Time (s)')
        f_list[1].axvline(1.5, color = 'k', linewidth = 0.5) 

        return fig

    def grid_plot_neural_activity_DLS(self, fig_size, sim_data, n_timepoints, tf_m):

        fig = plt.figure(constrained_layout=True, figsize = (fig_size[0],fig_size[1]))
        #fig.suptitle('Sampled Action Preferences', fontsize=16, y=1.02)

        gs = fig.add_gridspec(1, 2)

        f_list = [] 

        # DEFINING LOCATIONS OF THE FIGURES IN THE GRID PLOT
        
        f_list.append(fig.add_subplot(gs[0, 0]))
        f_list.append(fig.add_subplot(gs[0, 1])) 
        
        # removing top and right axis
        for f in f_list:
            f.spines['right'].set_visible(False)
            f.spines['top'].set_visible(False)
        
        # sample the data
        sA = self.sample_action_preferences_DLS(sim_data, n_timepoints, tf_m)
        
        f_list[0].plot(sA[0], np.mean(sA[1][0,0,:],axis = 0),'b')
        f_list[0].plot(sA[0], np.mean(sA[1][1,0,:],axis = 0),'r')
        f_list[0].set_ylabel(r'$A_{DLS}^{D,I}(CS)$')
        f_list[0].set_xlabel('Time (s)')
        f_list[0].axvline(1.5, color = 'k', linewidth = 0.5) 

        f_list[1].plot(sA[0], np.mean(sA[1][0,1,:],axis = 0),'b')
        f_list[1].plot(sA[0], np.mean(sA[1][1,1,:],axis = 0),'r')
        f_list[1].set_ylabel(r'$A_{DLS}^{D,I}(CS)$')
        f_list[1].set_xlabel('Time (s)')
        f_list[1].axvline(1.5, color = 'k', linewidth = 0.5) 

        return fig
    
    ## ANALYSIS
       
    def get_real_time_state_vec(self, tf_m, param):

        n_total_states = tf_m.env.n_total_states-1
        n_states = param['n_states']

        # GENERATES THE MAPPING BETWEEN THE STATE IN A TRIAL AND THE CORRESPONDING TIMPOINT --- make this a function
        real_time_to_state_vec = []
        for tone in range(tf_m.env.z_vec.shape[0]): # tones
            real_time_to_state_vec.append([])
            for trial in range(tf_m.env.z_vec.shape[1]): # trial types
                trial_id = [tone, trial]
                real_time_to_state_vec[tone].append([tf_m.env.z_vec[trial_id[0],trial_id[1]][0][0:-1][np.diff(tf_m.env.z_vec[trial_id[0],trial_id[1]][1]).astype(bool)],
                                                tf_m.env.z_vec[trial_id[0],trial_id[1]][1][0:-1][np.diff(tf_m.env.z_vec[trial_id[0],trial_id[1]][1]).astype(bool)].astype(int)])

        return real_time_to_state_vec

    def pf(self, x, alpha, beta):
        return 1. / (1 + np.exp( -(x-alpha)/beta ))

    def get_psychometric(self, t_vec, psych_long):
        # PSYCHOMETRIC 
        
        time_v = np.linspace(0.6,2.4,100)
        par0 = np.array([0.01, 1.]) # initial conditions of the fit
        par, mcov = curve_fit(self.pf, t_vec, psych_long, par0)
        
        return time_v, par, mcov

    def get_time_to_state_map(self, tf_m):
        
        time_st = []
        for tone in range(tf_m.env.z_vec.shape[0]): # tones
            time_st.append([])
            for trial in range(tf_m.env.z_vec.shape[1]): # trial types
                trial_id = [tone, trial]
                time_st[tone].append([tf_m.env.z_vec[trial_id[0],trial_id[1]][0][0:-1][np.diff(tf_m.env.z_vec[trial_id[0],trial_id[1]][1]).astype(bool)],
                                            tf_m.env.z_vec[trial_id[0],trial_id[1]][1][0:-1][np.diff(tf_m.env.z_vec[trial_id[0],trial_id[1]][1]).astype(bool)].astype(int)])
        return time_st

    def sample_action_preferences_DMS(self, sim_data, n_timepoints, tf_m):
        
        # need to make the gaussian sampled version of this code
        
        def find_nearest(array, value):
            array = np.asarray(array)
            idx = (np.abs(array - value)).argmin()
            return array[idx], idx
        
        # get the timepoint associated with each state
        time_st = self.get_time_to_state_map(tf_m)

        Ac = sim_data['Ac']
        time_vec = np.linspace(0.6, 2.5, n_timepoints)

        # generate state sequences and correspoding temporal points
        t_seq = []
        st_seq = []
        n_tones = len(time_st)-1
        for tr in range(len(time_st[n_tones])):
            t_seq.append([])
            st_seq.append([])
            time_seq = time_st[n_tones][tr][0]
            for i,e in enumerate(time_seq):
                if e > 0.6:
                    if time_st[n_tones][tr][1][i] < tf_m.env.n_states:
                        st_seq[tr].append(time_st[n_tones][tr][1][i])
                        t_seq[tr].append(find_nearest(time_vec, e)[0])

        # generate a sample A vector that lives in time_vec
        # for each trial fetch the corresponding action value
        # and put it in the right temporal box
        n_trials = len(time_st[n_tones-1])
        sAc = np.zeros((2,2,n_trials, time_vec.shape[0]))
        for p in range(2):
            for a in range(2):
                for tr in range(n_trials):
                    for i,ts in enumerate(t_seq[tr]):
                        idx = find_nearest(time_vec, ts)[1]
                        sAc[p,a,tr,idx] = Ac[p,st_seq[tr][i],a]
                        
        return time_vec, sAc

    def sample_action_preferences_DLS(self, sim_data, n_timepoints, tf_m):
    
        # need to make the gaussian sampled version of this code
        
        def find_nearest(array, value):
            array = np.asarray(array)
            idx = (np.abs(array - value)).argmin()
            return array[idx], idx
        
        # get the timepoint associated with each state
        time_st = self.get_time_to_state_map(tf_m)

        A = sim_data['A']
        time_vec = np.linspace(0.6, 2.5, n_timepoints)

        # generate state sequences and correspoding temporal points
        t_seq = []
        st_seq = []
        n_tones = len(time_st)-1
        for tr in range(len(time_st[n_tones])):
            t_seq.append([])
            st_seq.append([])
            time_seq = time_st[n_tones][tr][0]
            for i,e in enumerate(time_seq):
                if e > 0.6:
                    if time_st[n_tones][tr][1][i] < tf_m.env.n_states:
                        st_seq[tr].append(time_st[n_tones][tr][1][i])
                        t_seq[tr].append(find_nearest(time_vec, e)[0])

        # generate a sample A vector that lives in time_vec
        # for each trial fetch the corresponding action value
        # and put it in the right temporal box
        n_trials = len(time_st[n_tones-1])
        sA = np.zeros((2,2,n_trials, time_vec.shape[0]))
        for p in range(2):
            for a in range(2):
                for tr in range(n_trials):
                    for i,ts in enumerate(t_seq[tr]):
                        idx = find_nearest(time_vec, ts)[1]
                        sA[p,a,tr,idx] = A[p,st_seq[tr][i],a]
                        
        return time_vec, sA

    def get_psychometric_data(self, sim_data, param, choice_per_state, real_time_to_state_vec, trial_subset, n_bins):
    
        # psychometric, & performance
        short_ch_st_post = choice_per_state[2]
        long_ch_st_post = choice_per_state[3]
        
        short_ch_time_post = []
        long_ch_time_post = []
        
        # fetching time points for short decision
        t_point = 0
        exc_short = 0
        for e in short_ch_st_post:
            try:
                t_id = sim_data['trial_h'][e[0]].astype(int)
                ch_state = e[1]
                st_idx = np.where(real_time_to_state_vec[t_id[0]][t_id[1]][1] == ch_state)[0]
                t_point = real_time_to_state_vec[t_id[0]][t_id[1]][0][st_idx][0]
                short_ch_time_post.append(t_point)
            except:
                exc_short += 1
        short_ch_time_post = np.asarray(short_ch_time_post)
        
        t_point = 0
        exc_long = 0
        for e in long_ch_st_post:
            try:
                t_id = sim_data['trial_h'][e[0]].astype(int)
                ch_state = e[1]
                st_idx = np.where(real_time_to_state_vec[t_id[0]][t_id[1]][1] == ch_state)[0]
                t_point = real_time_to_state_vec[t_id[0]][t_id[1]][0][st_idx][0]
                long_ch_time_post.append(t_point)
            except: # need to understand these exceptions - something's not right here
                # I think the exceptions are coming from states beyond 
                exc_long += 1
        long_ch_time_post = np.asarray(long_ch_time_post)
        
        # PSYCHOMETRIC - the bin timepoints are not the same as the points we're after
        if trial_subset != False:
            t_vec_ps = [param['second_tone_list'][i] for i in trial_subset]
        else:
            t_vec_ps = param['second_tone_list']
            
        t_vec_bf = np.linspace(0.65, 2.5, n_bins)

        short_hist_psych = np.histogram(short_ch_time_post, t_vec_ps, n_bins)
        long_hist_psych = np.histogram(long_ch_time_post, t_vec_ps, n_bins)
        
        psych_long = long_hist_psych[0]/(long_hist_psych[0] + short_hist_psych[0])
        print(psych_long)

        return short_ch_time_post, long_ch_time_post, t_vec_bf, t_vec_ps[0:-1], psych_long  
    
    def calculate_hazard(self, sim_data, param, test, n_bins, trial_subset, init_f, tf_m):
    
        print('new haz')
        
        if test:
            ep_range = [0, sim_data['n_episodes']]
        else:
            ep_range = [int(param['n_episodes']*init_f), param['n_episodes']]
        
        bins = np.linspace(0.6,2.4, n_bins)
        rt_st_v = self.get_real_time_state_vec(tf_m, param)
        choice_per_state = self.get_choices_per_state(sim_data, ep_range)
        ps_data = self.get_psychometric_data(sim_data, param, choice_per_state, rt_st_v, trial_subset, n_bins)
        bf_data = self.get_breaking_fixation_data(sim_data, choice_per_state, rt_st_v, n_bins)

        # long_ch_time_post, short_ch_time_post
        completed_tr = np.histogram(np.concatenate((ps_data[0],ps_data[1])),bins)
        
        ## long_ch_time_pre, short_ch_time_pre
        bf_short =  np.histogram(bf_data[1], bins)
        bf_long =  np.histogram(bf_data[2], bins)
        bf_total = np.histogram(np.concatenate((bf_data[1],bf_data[2])), bins)
        
        hazard_total = np.zeros(n_bins)
        hazard_short = np.zeros(n_bins)
        hazard_long = np.zeros(n_bins)
        
        for i,e in enumerate(bf_total[0]):
            hazard_total[i] = bf_total[0][i]/(sum(bf_total[0][i:])+sum(completed_tr[0][i:]))
            hazard_short[i] = bf_short[0][i]/(sum(bf_total[0][i:])+sum(completed_tr[0][i:]))        
            hazard_long[i] = bf_long[0][i]/(sum(bf_total[0][i:])+sum(completed_tr[0][i:]))
            
        return bins, hazard_total, hazard_short, hazard_long
 
    def get_choices_per_state(self, sim_data, ep_range):

        # FETCHING THE ANSWERS FOR PRE AND POST SECOND TONE STATES --- make this a function
        long_ch_st_pre = [] # long ch state and episode - pre second tone
        short_ch_st_pre = [] # short ch state and episode - pre second tone 
        long_ch_st_post = [] # long ch state and episode - post second tone 
        short_ch_st_post = [] # short ch state and episode - post second tone
        
        n_states = sim_data['param']['n_states']
        n_total_states = n_states * 2
        
        for ep in range(ep_range[0], ep_range[1]):
            # checking for breaking fixations
            if np.where(sim_data['behaviour_h'][ep] == 0)[0].shape[0] != 0 and np.where(sim_data['behaviour_h'][ep] == 0)[0][0] != n_total_states and np.where(sim_data['behaviour_h'][ep] == 0)[0][0] < n_states:
                short_ch_st_pre.append(np.asarray([ep, np.where(sim_data['behaviour_h'][ep] == 0)[0][0]]))
            if np.where(sim_data['behaviour_h'][ep] == 1)[0].shape[0] != 0 and np.where(sim_data['behaviour_h'][ep] == 1)[0][0] != n_total_states and np.where(sim_data['behaviour_h'][ep] == 1)[0][0] < n_states:
                long_ch_st_pre.append(np.asarray([ep, np.where(sim_data['behaviour_h'][ep] == 1)[0][0]]))

            # checking for correct trials - change is at > n_states
            if np.where(sim_data['behaviour_h'][ep] == 0)[0].shape[0] != 0 and np.where(sim_data['behaviour_h'][ep] == 0)[0][0] != n_total_states and np.where(sim_data['behaviour_h'][ep] == 0)[0][0] > n_states:
                short_ch_st_post.append(np.asarray([ep, np.where(sim_data['behaviour_h'][ep] == 0)[0][0]]))
            if np.where(sim_data['behaviour_h'][ep] == 1)[0].shape[0] != 0 and np.where(sim_data['behaviour_h'][ep] == 1)[0][0] != n_total_states and np.where(sim_data['behaviour_h'][ep] == 1)[0][0] > n_states:
                long_ch_st_post.append(np.asarray([ep, np.where(sim_data['behaviour_h'][ep] == 1)[0][0]]))

        return np.asarray(short_ch_st_pre), np.asarray(long_ch_st_pre), np.asarray(short_ch_st_post), np.asarray(long_ch_st_post)

    def get_breaking_fixation_data(self, sim_data, choice_per_state, real_time_to_state_vec, n_bins):
    
        short_ch_st_pre = choice_per_state[0]
        long_ch_st_pre = choice_per_state[1]
        
        # fetching time points for short decision
        short_ch_time_pre = []
        t_point = 0
        exc_short = 0
        for e in short_ch_st_pre:
            try:
                t_id = sim_data['trial_h'][e[0]].astype(int)
                ch_state = e[1]
                st_idx = np.where(real_time_to_state_vec[t_id[0]][t_id[1]][1] == ch_state)[0]
                t_point = real_time_to_state_vec[t_id[0]][t_id[1]][0][st_idx][0]
                short_ch_time_pre.append(t_point)
            except:
                exc_short += 1
        short_ch_time_pre = np.asarray(short_ch_time_pre)
        
        long_ch_time_pre = []
        t_point = 0
        exc_long = 0
        for e in long_ch_st_pre:
            try:
                t_id = sim_data['trial_h'][e[0]].astype(int)
                ch_state = e[1]
                st_idx = np.where(real_time_to_state_vec[t_id[0]][t_id[1]][1] == ch_state)[0]
                t_point = real_time_to_state_vec[t_id[0]][t_id[1]][0][st_idx][0]
                long_ch_time_pre.append(t_point)
            except: # need to understand these exceptions - something's not right here
                # I think the exceptions are coming from states beyond 
                exc_long += 1
        long_ch_time_pre = np.asarray(long_ch_time_pre)
        
        t_vec_bf = np.linspace(0.65, 2.5, n_bins)
        
        return t_vec_bf, short_ch_time_pre, long_ch_time_pre

    def get_pbreak(self, sim_data, tf_m):
        
        bf_left = (sim_data['behaviour_h'][:,0:tf_m.n_states] == 0).astype(int)
        bf_right = (sim_data['behaviour_h'][:,0:tf_m.n_states] == 1).astype(int)
        total_bf_m = bf_left + bf_right
        total_bf_st = np.sum(total_bf_m,axis = 0)
        p_break = np.sum(total_bf_st)/total_bf_m.shape[0]
        
        return p_break

    def get_perf(self, sim_data):
        
        corr_st = np.sum((sim_data['choice_v'] == 2).astype(int), axis = 0)
        corr_all = np.sum(corr_st)
        inc_st = np.sum((sim_data['choice_v'] == 3).astype(int), axis = 0)
        inc_all = np.sum(inc_st)
        perf = corr_all/(corr_all+inc_all)
        
        return perf

    def get_behavior_metrics_opto(self, control_data, opto_data, tf_m):
        
        perf = self.get_perf(opto_data)
        p_break = self.get_pbreak(opto_data,tf_m)
        p_break_ctrl = self.get_pbreak(control_data, tf_m)
        bias_long_ctrl = self.get_biaslong_pbreak(control_data, tf_m)
        bias_long_opto = self.get_biaslong_pbreak(opto_data, tf_m)
        delta_bf_long = bias_long_opto - bias_long_ctrl
        
        return [perf, p_break, delta_bf_long, p_break_ctrl]

    def get_biaslong_pbreak(self, sim_data, tf_m):

        bf_short = (sim_data['behaviour_h'][:,0:tf_m.n_states] == 0).astype(int)
        bf_long = (sim_data['behaviour_h'][:,0:tf_m.n_states] == 1).astype(int)
        total_bf_m = bf_short + bf_long
        bf_long_count = np.sum(np.sum(bf_long, axis = 0))
        bias_long = bf_long_count / total_bf_m.shape[0]
        
        #print(bf_long_count, total_bf_m.shape[0])

        return bias_long


    # DATASET GENERATION

    # change this name, this is the behaviour_dataframe

    def generate_data_structure(self, sim_data, param, tf_m):

        isBrokenFixation = 0
        BrokenFixationTime = 0
        Interval = 0 
        ChoiceAfterBrokenFixation = 0
        ChoiceCorrectAfterValidTrial = 0
        IsOptoTrial = 0
        
        time_st = self.get_time_to_state_map(tf_m)
        
        row_df = {'isBrokenFixation': isBrokenFixation, 'BrokenFixationTime': BrokenFixationTime, 'Interval': Interval, 
                            'ChoiceAfterBrokenFixation': ChoiceAfterBrokenFixation, 'ChoiceCorrectAfterValidTrial': ChoiceCorrectAfterValidTrial, 
                            'IsOptoTrial': IsOptoTrial}
        test_df = pd.DataFrame(data = row_df, index = [0])

        for e,d in zip(sim_data['behaviour_h'], sim_data['trial_h']):

            Interval = param['second_tone_list'][int(d[0])]
            trial_id = [int(d[0]),int(d[1])]
            if np.where(e == 0)[0] < param['n_states']:
                st = np.where(e == 0)[0][0]
                BrokenFixationTime = time_st[trial_id[0],trial_id[1]][0][st]
                isBrokenFixation = 1
                ChoiceAfterBrokenFixation = 'Left'
                ChoiceCorrectAfterValidTrial = NaN
                
            if np.where(e == 1)[0] < param['n_states']:
                st = np.where(e == 1)[0][0]
                BrokenFixationTime = time_st[trial_id[0],trial_id[1]][0][st]
                isBrokenFixation = 1
                ChoiceAfterBrokenFixation = 'Right'
                ChoiceCorrectAfterValidTrial = NaN

            if np.where(e == 0)[0] > param['n_states']:
                isBrokenFixation = 0
                BrokenFixationTime = NaN
                ChoiceCorrectAfterValidTrial = 'Left'
                ChoiceAfterBrokenFixation = NaN

            if np.where(e == 1)[0] > param['n_states']:
                isBrokenFixation = 0
                BrokenFixationTime = NaN
                ChoiceCorrectAfterValidTrial = 'Right'
                ChoiceAfterBrokenFixation = NaN

            row_df = {'isBrokenFixation': isBrokenFixation, 'BrokenFixationTime': BrokenFixationTime, 'Interval': Interval, 
                            'ChoiceAfterBrokenFixation': ChoiceAfterBrokenFixation, 'ChoiceCorrectAfterValidTrial': ChoiceCorrectAfterValidTrial, 
                            'IsOptoTrial': IsOptoTrial}
            test_df = test_df.append(row_df, ignore_index = True)
            
        return test_df

    def fill_dataframe(self, sim_data, param, df, is_opto, time_st):
    
        # CHANGE THE NAME OF THIS FUNCTION!!!
        
        isBrokenFixation = 0
        BrokenFixationTime = 0
        Interval = 0 
        ChoiceAfterBrokenFixation = 0
        ChoiceCorrectAfterValidTrial = 0
        IsOptoTrial = 0
        
        for e,d in zip(sim_data['behaviour_h'], sim_data['trial_h']):

            Interval = param['second_tone_list'][int(d[0])]
            trial_id = [int(d[0]),int(d[1])]
            if np.where(e == 0)[0] < param['n_states']:
                st = np.where(e == 0)[0][0]
                BrokenFixationTime = time_st[trial_id[0],trial_id[1]][0][st]
                isBrokenFixation = 1
                ChoiceAfterBrokenFixation = 'Left'
                ChoiceCorrectAfterValidTrial = NaN
                IsOptoTrial = is_opto
            if np.where(e == 1)[0] < param['n_states']:
                st = np.where(e == 1)[0][0]
                BrokenFixationTime = time_st[trial_id[0],trial_id[1]][0][st]
                isBrokenFixation = 1
                ChoiceAfterBrokenFixation = 'Right'
                ChoiceCorrectAfterValidTrial = NaN
                IsOptoTrial = is_opto
            if np.where(e == 0)[0] > param['n_states']:
                isBrokenFixation = 0
                BrokenFixationTime = NaN
                ChoiceCorrectAfterValidTrial = 'Left'
                ChoiceAfterBrokenFixation = NaN
                IsOptoTrial = is_opto
            if np.where(e == 1)[0] > param['n_states']:
                isBrokenFixation = 0
                BrokenFixationTime = NaN
                ChoiceCorrectAfterValidTrial = 'Right'
                ChoiceAfterBrokenFixation = NaN
                IsOptoTrial = is_opto
            row_df = {'isBrokenFixation': isBrokenFixation, 'BrokenFixationTime': BrokenFixationTime, 'Interval': Interval, 
                            'ChoiceAfterBrokenFixation': ChoiceAfterBrokenFixation, 'ChoiceCorrectAfterValidTrial': ChoiceCorrectAfterValidTrial, 
                            'IsOptoTrial': IsOptoTrial}
            df = df.append(row_df, ignore_index = True)
        
        
        return df

    def generate_act_pref_dataframe_mean(self, sim_data, n_timepoints, tf_m):
    
        sA_DLS = self.sample_action_preferences_DLS(sim_data, n_timepoints, tf_m)
        sA_DMS = self.sample_action_preferences_DMS(sim_data, n_timepoints, tf_m)
        
        time_v = sA_DLS[0]
        dls_ADL = np.mean(sA_DLS[1][0,0,:],axis = 0)
        dls_ADR = np.mean(sA_DLS[1][0,1,:],axis = 0)
        dls_AIL = np.mean(sA_DLS[1][1,0,:],axis = 0)
        dls_AIR = np.mean(sA_DLS[1][1,1,:],axis = 0)
        
        dms_ADL = np.mean(sA_DMS[1][0,0,:],axis = 0)
        dms_ADR = np.mean(sA_DMS[1][0,1,:],axis = 0)
        dms_AIL = np.mean(sA_DMS[1][1,0,:],axis = 0)
        dms_AIR = np.mean(sA_DMS[1][1,1,:],axis = 0)

        dls_actP_direct_left = 0
        dls_actP_direct_right = 0
        dls_actP_indirect_left = 0
        dls_actP_indirect_right = 0
        
        dms_actP_direct_left = 0
        dms_actP_direct_right = 0
        dms_actP_indirect_left = 0
        dms_actP_indirect_right = 0
        
        timepoint = 0
        
        row_df = {'dls_actP_direct_left': dls_actP_direct_left,
                'dls_actP_direct_right': dls_actP_direct_right,
                'dls_actP_indirect_left': dls_actP_indirect_left,
                'dls_actP_indirect_right': dls_actP_indirect_right,
                'dms_actP_direct_left': dms_actP_direct_left,
                'dms_actP_direct_right': dms_actP_direct_right,
                'dms_actP_indirect_left': dms_actP_indirect_left,
                'dms_actP_indirect_right': dms_actP_indirect_right,
                'timepoint' : timepoint
                }

        df = pd.DataFrame(data = row_df, index = [0])
        
        
        for i in range(sA_DLS[0].shape[0]):
            dls_actP_direct_left = dls_ADL[i]
            dls_actP_direct_right = dls_ADR[i]
            dls_actP_indirect_left = dls_AIL[i]
            dls_actP_indirect_right = dls_AIR[i]
            
            dms_actP_direct_left = dms_ADL[i]
            dms_actP_direct_right = dms_ADR[i]
            dms_actP_indirect_left = dms_AIL[i]
            dms_actP_indirect_right = dms_AIR[i]
            
            timepoint = time_v[i]
            
            row_df = {'dls_actP_direct_left': dls_actP_direct_left,
                'dls_actP_direct_right': dls_actP_direct_right,
                'dls_actP_indirect_left': dls_actP_indirect_left,
                'dls_actP_indirect_right': dls_actP_indirect_right,
                'dms_actP_direct_left': dms_actP_direct_left,
                'dms_actP_direct_right': dms_actP_direct_right,
                'dms_actP_indirect_left': dms_actP_indirect_left,
                'dms_actP_indirect_right': dms_actP_indirect_right,
                'timepoint' : timepoint
                }
            
            df = df.append(row_df, ignore_index = True)

        return df[1:-1]

    def generate_act_pref_dataframe_noise_dls_dms(self, sim_data, n_timepoints, tf_m, n_eps, s_noise):
    
        # generates a dataframe with the different trial types randomly sampled n_eps times
        # this dataset is to be used for statistics
        
        sA_DLS = self.sample_action_preferences_DLS(sim_data, n_timepoints, tf_m)
        sA_DMS = self.sample_action_preferences_DMS(sim_data, n_timepoints, tf_m)
        
        time_v = sA_DLS[0]
        dls_ADL = sA_DLS[1][0,0,:]
        dls_ADR = sA_DLS[1][0,1,:]
        dls_AIL = sA_DLS[1][1,0,:]
        dls_AIR = sA_DLS[1][1,1,:]
        
        dms_ADL = sA_DMS[1][0,0,:]
        dms_ADR = sA_DMS[1][0,1,:]
        dms_AIL = sA_DMS[1][1,0,:]
        dms_AIR = sA_DMS[1][1,1,:]

        dls_actP_direct_left = 0
        dls_actP_direct_right = 0
        dls_actP_indirect_left = 0
        dls_actP_indirect_right = 0
        
        dms_actP_direct_left = 0
        dms_actP_direct_right = 0
        dms_actP_indirect_left = 0
        dms_actP_indirect_right = 0
        
        timepoint = 0
        
        row_df = {'dls_actP_direct_left': dls_actP_direct_left,
                'dls_actP_direct_right': dls_actP_direct_right,
                'dls_actP_indirect_left': dls_actP_indirect_left,
                'dls_actP_indirect_right': dls_actP_indirect_right,
                'dms_actP_direct_left': dms_actP_direct_left,
                'dms_actP_direct_right': dms_actP_direct_right,
                'dms_actP_indirect_left': dms_actP_indirect_left,
                'dms_actP_indirect_right': dms_actP_indirect_right,
                'timepoint' : timepoint
                }

        df = pd.DataFrame(data = row_df, index = [0])

        ### sampling action preferences
        
        for ep in range(n_eps):
            tr_idx = np.arange(0, dls_ADL.shape[0],1)
            tr = np.random.choice(tr_idx)
            for i in range(time_v.shape[0]):
                dls_actP_direct_left = dls_ADL[tr, i] + np.random.normal(0,s_noise)
                dls_actP_direct_right = dls_ADR[tr, i] + np.random.normal(0,s_noise)
                dls_actP_indirect_left = dls_AIL[tr, i] + np.random.normal(0,s_noise)
                dls_actP_indirect_right = dls_AIR[tr, i] + np.random.normal(0,s_noise)

                dms_actP_direct_left = dms_ADL[tr, i] + np.random.normal(0,s_noise)
                dms_actP_direct_right = dms_ADR[tr, i] + np.random.normal(0,s_noise)
                dms_actP_indirect_left = dms_AIL[tr, i] + np.random.normal(0,s_noise)
                dms_actP_indirect_right = dms_AIR[tr, i] + np.random.normal(0,s_noise)

                timepoint = time_v[i]

                row_df = {'dls_actP_direct_left': dls_actP_direct_left,
                    'dls_actP_direct_right': dls_actP_direct_right,
                    'dls_actP_indirect_left': dls_actP_indirect_left,
                    'dls_actP_indirect_right': dls_actP_indirect_right,
                    'dms_actP_direct_left': dms_actP_direct_left,
                    'dms_actP_direct_right': dms_actP_direct_right,
                    'dms_actP_indirect_left': dms_actP_indirect_left,
                    'dms_actP_indirect_right': dms_actP_indirect_right,
                    'timepoint' : timepoint
                    }

                df = df.append(row_df, ignore_index = True)

        df = df[1:-1]

        # put timepoint in first column
        tp = df['timepoint']
        df.drop(labels=['timepoint'], axis=1,inplace = True)
        df.insert(0, 'timepoint', tp)

        return df

    def generate_act_pref_dataframe_noise(self, sim_data, n_timepoints, tf_m, n_eps, s_noise):
    
        # generates a dataframe with the different trial types randomly sampled n_eps times
        # this dataset is to be used for statistics
        
        sA = sample_action_preferences(sim_data, n_timepoints, tf_m)
        time_v = sA[0]

        ADL = sA[1][0,0,:]
        ADR = sA[1][0,1,:]
        AIL = sA[1][1,0,:]
        AIR = sA[1][1,1,:]
        AML = sA[2][0,:]
        AMR = sA[2][1,:]


        timepoint = 0
        actP_direct_left = 0
        actP_direct_right = 0
        actP_indirect_left = 0
        actP_indirect_right = 0
        actP_DM_left = 0
        actP_DM_right = 0

        row_df = {'actP_direct_left': actP_direct_left,
                'actP_direct_right': actP_direct_right,
                'actP_indirect_left': actP_indirect_left,
                'actP_indirect_right': actP_indirect_right,
                'actP_DM_left': actP_DM_left,
                'actP_DM_right': actP_DM_right,
                'timepoint' : timepoint
                }

        df = pd.DataFrame(data = row_df, index = [0])

        for ep in range(n_eps):
            tr_idx = np.arange(0,ADL.shape[0],1)
            tr = np.random.choice(tr_idx)
            for i in range(time_v.shape[0]):
                    actP_direct_left = ADL[tr,i] + np.random.normal(0,s_noise)
                    actP_direct_right = ADR[tr,i] + np.random.normal(0,s_noise)
                    actP_indirect_left = AIL[tr, i] + np.random.normal(0,s_noise)
                    actP_indirect_right = AIR[tr, i] + np.random.normal(0,s_noise)
                    actP_DM_left = AML[tr, i] + np.random.normal(0,s_noise)
                    actP_DM_right = AMR[tr, i] + np.random.normal(0,s_noise)
                    timepoint = time_v[i]

                    row_df = {'timepoint' : timepoint,
                        'actP_direct_left': actP_direct_left,
                        'actP_direct_right': actP_direct_right,
                        'actP_indirect_left': actP_indirect_left,
                        'actP_indirect_right': actP_indirect_right,
                        'actP_DM_left': actP_DM_left,
                        'actP_DM_right': actP_DM_right
                        }

                    df = df.append(row_df, ignore_index = True)

        df = df[1:-1]

        # put timepoint in first column
        tp = df['timepoint']
        df.drop(labels=['timepoint'], axis=1,inplace = True)
        df.insert(0, 'timepoint', tp)

        return df


    def generate_data_structure_single(self, sim_data, param, tf_m, is_opto):

        isBrokenFixation = 0
        BrokenFixationTime = 0
        Interval = 0 
        ChoiceAfterBrokenFixation = 0
        ChoiceCorrectAfterValidTrial = 0
        IsOptoTrial = 0
        
        time_st = self.get_time_to_state_map(tf_m)
        
        row_df = {'isBrokenFixation': isBrokenFixation, 'BrokenFixationTime': BrokenFixationTime, 'Interval': Interval, 
                            'ChoiceAfterBrokenFixation': ChoiceAfterBrokenFixation, 'ChoiceCorrectAfterValidTrial': ChoiceCorrectAfterValidTrial, 
                            'IsOptoTrial': IsOptoTrial}
        df = pd.DataFrame(data = row_df, index = [0])

        df = self.fill_dataframe(sim_data, param, df, is_opto, time_st)
            
        return df

    def generate_data_structure_all(self, control_data, pert_bl_data, pert_cs_data, pert_cl_data, param, tf_m):
        
        # might as well create a data dictionary

        isBrokenFixation = 0
        BrokenFixationTime = 0
        Interval = 0 
        ChoiceAfterBrokenFixation = 0
        ChoiceCorrectAfterValidTrial = 0
        IsOptoTrial = 0
        
        time_st = self.get_time_to_state_map(tf_m)
        
        row_df = {'isBrokenFixation': isBrokenFixation, 'BrokenFixationTime': BrokenFixationTime, 'Interval': Interval, 
                            'ChoiceAfterBrokenFixation': ChoiceAfterBrokenFixation, 'ChoiceCorrectAfterValidTrial': ChoiceCorrectAfterValidTrial, 
                            'IsOptoTrial': IsOptoTrial}
        df = pd.DataFrame(data = row_df, index = [0])

        df = self.fill_dataframe(control_data, param, df, 0, time_st)
        print('finished control trials')
        df = self.fill_dataframe(pert_bl_data, param, df, 2, time_st)
        print('finished bilateral pert trials')
        df = self.fill_dataframe(pert_cs_data, param, df, 1, time_st)
        print('finished contra-short pert trials')
        df = self.fill_dataframe(pert_cl_data, param, df, -1, time_st)
        print('finished contra-long pert trials')
        
        # dorsomedial keys -> bl 3, cs -3, cl 4
        
        return df

    def generate_data_structure_all_v2(self, all_data, param, tf_m):
        
        # can take 3 magnitudes of perturbation
        # however this is not as systematic as it should be
        
        print('Generating dataset for the following functions: ')
        for k,e in all_data.items():
            print(k)

        isBrokenFixation = 0
        BrokenFixationTime = 0
        Interval = 0 
        ChoiceAfterBrokenFixation = 0
        ChoiceCorrectAfterValidTrial = 0
        IsOptoTrial = 0
        
        time_st = self.get_time_to_state_map(tf_m)
        
        row_df = {'isBrokenFixation': isBrokenFixation, 'BrokenFixationTime': BrokenFixationTime, 'Interval': Interval, 
                            'ChoiceAfterBrokenFixation': ChoiceAfterBrokenFixation, 'ChoiceCorrectAfterValidTrial': ChoiceCorrectAfterValidTrial, 
                            'IsOptoTrial': IsOptoTrial}
        df = pd.DataFrame(data = row_df, index = [0])
        
        print('generating control dataset')
        df = self.fill_dataframe(all_data['test_data'], param, df, 'CTRL', time_st)
        
        # indirect pathway
        print('generating a2a dataset bl')
        df = self.fill_dataframe(all_data['pert_a2a_bl'][0][0], param, df, 'PERT_A2A_BL_HIGH', time_st)
        print('H')
        df = self.fill_dataframe(all_data['pert_a2a_bl'][1][0], param, df, 'PERT_A2A_BL_MID', time_st)
        print('M')
        df = self.fill_dataframe(all_data['pert_a2a_bl'][2][0], param, df, 'PERT_A2A_BL_LOW', time_st)
        print('L')
        
        print('generating a2a dataset cs')
        df = self.fill_dataframe(all_data['pert_a2a_cs'][0][0], param, df, 'PERT_A2A_CS_HIGH', time_st)
        print('H')
        df = self.fill_dataframe(all_data['pert_a2a_cs'][1][0], param, df, 'PERT_A2A_CS_MID', time_st)
        print('M')
        df = self.fill_dataframe(all_data['pert_a2a_cs'][2][0], param, df, 'PERT_A2A_CS_LOW', time_st)
        print('L')
        
        print('generating a2a dataset cl')
        df = self.fill_dataframe(all_data['pert_a2a_cl'][0][0], param, df, 'PERT_A2A_CL_HIGH', time_st)
        print('H')
        df = self.fill_dataframe(all_data['pert_a2a_cl'][1][0], param, df, 'PERT_A2A_CL_MID', time_st)
        print('M')
        df = self.fill_dataframe(all_data['pert_a2a_cl'][2][0], param, df, 'PERT_A2A_CL_LOW', time_st)
        print('L')
        
        # dorsomedial pathway
        print('generating dm dataset bl')
        df = self.fill_dataframe(all_data['pert_dm_bl'][0][0], param, df, 'PERT_DM_BL_HIGH', time_st)
        print('H')
        df = self.fill_dataframe(all_data['pert_dm_bl'][1][0], param, df, 'PERT_DM_BL_MID', time_st)
        print('M')
        df = self.fill_dataframe(all_data['pert_dm_bl'][2][0], param, df, 'PERT_DM_BL_LOW', time_st)
        print('L')
        
        print('generating dm dataset cs')
        df = self.fill_dataframe(all_data['pert_dm_cs'][0][0], param, df, 'PERT_DM_CS_HIGH', time_st)
        print('H')
        df = self.fill_dataframe(all_data['pert_dm_cs'][1][0], param, df, 'PERT_DM_CS_MID', time_st)
        print('M')
        df = self.fill_dataframe(all_data['pert_dm_cs'][2][0], param, df, 'PERT_DM_CS_LOW', time_st)
        print('L')
        
        print('generating dm dataset cl')
        df = self.fill_dataframe(all_data['pert_dm_cl'][0][0], param, df, 'PERT_DM_CL_HIGH', time_st)
        print('H')
        df = self.fill_dataframe(all_data['pert_dm_cl'][1][0], param, df, 'PERT_DM_CL_MID', time_st)
        print('M')
        df = self.fill_dataframe(all_data['pert_dm_cl'][2][0], param, df, 'PERT_DM_CL_LOW', time_st)
        print('L')
        
        return df

    def generate_data_structure_all_v3(self, all_data, param, tf_m):
    
        # generates datastructure for only one of the perturbation markers define in v2
        # these two functions should be merged at some point...
        
        print('Generating dataset for the following functions: ')
        for k,e in all_data.items():
            print(k)

        isBrokenFixation = 0
        BrokenFixationTime = 0
        Interval = 0 
        ChoiceAfterBrokenFixation = 0
        ChoiceCorrectAfterValidTrial = 0
        IsOptoTrial = 0
        
        time_st = self.get_time_to_state_map(tf_m)
        
        row_df = {'isBrokenFixation': isBrokenFixation, 'BrokenFixationTime': BrokenFixationTime, 'Interval': Interval, 
                            'ChoiceAfterBrokenFixation': ChoiceAfterBrokenFixation, 'ChoiceCorrectAfterValidTrial': ChoiceCorrectAfterValidTrial, 
                            'IsOptoTrial': IsOptoTrial}
        df = pd.DataFrame(data = row_df, index = [0])
        
        print('generating control dataset')
        df = self.fill_dataframe(all_data['test_data'], param, df, 'CTRL', time_st)
        
        # indirect pathway
        print('generating a2a dataset bl')
        df = self.fill_dataframe(all_data['pert_a2a_bl'][0][0], param, df, 'PERT_A2A_BL_HIGH', time_st)
        print('H')
        
        print('generating a2a dataset cs')
        df = self.fill_dataframe(all_data['pert_a2a_cs'][0][0], param, df, 'PERT_A2A_CS_HIGH', time_st)
        print('H')
        
        print('generating a2a dataset cl')
        df = self.fill_dataframe(all_data['pert_a2a_cl'][0][0], param, df, 'PERT_A2A_CL_HIGH', time_st)
        print('H')
        
        # dorsomedial pathway
        print('generating dm dataset bl')
        df = self.fill_dataframe(all_data['pert_dm_bl'][0][0], param, df, 'PERT_DM_BL_HIGH', time_st)
        print('H')
        
        print('generating dm dataset cs')
        df = self.fill_dataframe(all_data['pert_dm_cs'][0][0], param, df, 'PERT_DM_CS_HIGH', time_st)
        print('H')
        
        print('generating dm dataset cl')
        df = self.fill_dataframe(all_data['pert_dm_cl'][0][0], param, df, 'PERT_DM_CL_HIGH', time_st)
        print('H')
        
        return df

    
    def grid_plot_neural_activity_DMS_DLS(self, fig_size, sim_data, n_timepoints, tf_m):

        fig = plt.figure(constrained_layout=True, figsize = (fig_size[0],fig_size[1]))
        gs = fig.add_gridspec(2, 2)

        f_list = [] 

        # DEFINING LOCATIONS OF THE FIGURES IN THE GRID PLOT

        f_list.append(fig.add_subplot(gs[0, 0])) #0 - haz
        f_list.append(fig.add_subplot(gs[0, 1])) #1 - bf left
        f_list.append(fig.add_subplot(gs[1, 0])) #1 - bf left
        f_list.append(fig.add_subplot(gs[1, 1])) #1 - bf left
        

        # removing top and right axis
        for f in f_list:
            f.spines['right'].set_visible(False)
            f.spines['top'].set_visible(False)

        # sample the data
        sA_dms = self.sample_action_preferences_DMS(sim_data, n_timepoints, tf_m)
        sA_dls = self.sample_action_preferences_DLS(sim_data, n_timepoints, tf_m)

        d_dls_cs = np.mean(sA_dls[1][0,0,:],axis = 0)
        i_dls_cs = np.mean(sA_dls[1][1,0,:],axis = 0)
        d_dls_cl = np.mean(sA_dls[1][0,1,:],axis = 0)
        i_dls_cl = np.mean(sA_dls[1][1,1,:],axis = 0)
        
        d_dms_cs = np.mean(sA_dms[1][0,0,:],axis = 0)
        i_dms_cs = np.mean(sA_dms[1][1,0,:],axis = 0)
        d_dms_cl = np.mean(sA_dms[1][0,1,:],axis = 0)
        i_dms_cl = np.mean(sA_dms[1][1,1,:],axis = 0)
        
        y_all_dls = [d_dls_cs, i_dls_cs, d_dls_cl, i_dls_cl] 
        y_all_dms = [d_dms_cs, i_dms_cs, d_dms_cl, i_dms_cl]
        
        shft = 2
        y_max_dls = max([max(e) for e in y_all_dls]) + shft
        y_min_dls = min([min(e) for e in y_all_dls]) - shft
        y_max_dms = max([max(e) for e in y_all_dms]) + shft
        y_min_dms = min([min(e) for e in y_all_dms]) - shft
        
        lw = 2
        x_max = -1
        
        f_list[0].plot(sA_dls[0][0:x_max], np.mean(sA_dls[1][0,1,:],axis = 0)[0:x_max],'b', linewidth = 3)
        f_list[0].plot(sA_dls[0][0:x_max], np.mean(sA_dls[1][1,1,:],axis = 0)[0:x_max],'r', linewidth = 3)
        f_list[0].set_ylabel(r'$A_{DLS}^{D,I}(CL)$')
        f_list[0].set_xlabel('Time (s)')
        f_list[0].axvline(1.5, color = 'k', linewidth = 0.5) 
        f_list[0].set_ylim(y_min_dls, y_max_dls)
        f_list[0].set_xticks([0.6,1.5,2.4])
        
        f_list[1].plot(sA_dls[0][0:x_max], np.mean(sA_dls[1][0,0,:],axis = 0)[0:x_max],'b', linewidth = 3)
        f_list[1].plot(sA_dls[0][0:x_max], np.mean(sA_dls[1][1,0,:],axis = 0)[0:x_max],'r', linewidth = 3)
        f_list[1].set_ylabel(r'$A_{DLS}^{D,I}(CS)$')
        f_list[1].set_xlabel('Time (s)')
        f_list[1].axvline(1.5, color = 'k', linewidth = 0.5)
        f_list[1].set_ylim(y_min_dls, y_max_dls)
        f_list[1].set_xticks([0.6,1.5,2.4])
        
        f_list[2].plot(sA_dms[0][0:x_max], np.mean(sA_dms[1][0,1,:],axis = 0)[0:x_max],'b', linewidth = 3)
        f_list[2].plot(sA_dms[0][0:x_max], np.mean(sA_dms[1][1,1,:],axis = 0)[0:x_max],'r', linewidth = 3)
        f_list[2].set_ylabel(r'$A_{DMS}^{D,I}(CL)$')
        f_list[2].set_xlabel('Time (s)')
        f_list[2].axvline(1.5, color = 'k', linewidth = 0.5) 
        f_list[2].set_ylim(y_min_dms, y_max_dms)
        f_list[2].set_xticks([0.6,1.5,2.4])

        f_list[3].plot(sA_dms[0][0:x_max], np.mean(sA_dms[1][0,0,:],axis = 0)[0:x_max],'b', linewidth = 3)
        f_list[3].plot(sA_dms[0][0:x_max], np.mean(sA_dms[1][1,0,:],axis = 0)[0:x_max],'r', linewidth = 3)
        f_list[3].set_ylabel(r'$A_{DMS}^{D,I}(CS)$')
        f_list[3].set_xlabel('Time (s)')
        f_list[3].axvline(1.5, color = 'k', linewidth = 0.5) 
        f_list[3].set_ylim(y_min_dms, y_max_dms)
        f_list[3].set_xticks([0.6,1.5,2.4])
        

        
        return fig
